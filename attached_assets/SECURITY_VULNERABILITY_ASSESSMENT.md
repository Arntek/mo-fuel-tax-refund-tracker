# Security Vulnerability Assessment

**Application:** MO Fuel Tax Refund Tracker  
**Date:** December 28, 2025  
**Assessment Type:** API and Data Access Security Review

---

## Overview

This document outlines security vulnerabilities identified in the API and data access patterns of the MO Fuel Tax Refund Tracker application. These findings should be addressed in priority order.

---

## ðŸ”´ CRITICAL Issues

### 1. âœ… COMPLETED: Sensitive Data Encryption (SSN, FEIN)

**Status:** Fixed on December 28, 2025

**Implementation:**
- Integrated `server/encryption.ts` module into account creation/update flows in `server/storage.ts`
- SSN, spouseSsn, and FEIN are now encrypted on write using `encryptSSN()` function
- Values are decrypted and formatted on read using `decryptSSN()` with `formatSSN()` and `formatEIN()`
- AES-256-GCM encryption with random IV per encryption
- Frontend auto-formats SSN (XXX-XX-XXXX) and EIN (XX-XXXXXXX) with real-time dash insertion

---

### 2. âœ… COMPLETED: Rate Limiting on Authentication Endpoints

**Status:** Fixed on December 28, 2025

**Implementation:**
- Installed `express-rate-limit` package
- Applied rate limits using `express-rate-limit`:
  - `/api/auth/request-code`: 3 requests per 15 minutes per IP/email (`authCodeRequestLimiter`)
  - `/api/auth/verify-code`: 5 attempts per 15 minutes per email (`authCodeVerifyLimiter`)
  - `/api/auth/signup`: 5 requests per hour per IP (`signupLimiter`)
- Rate limiters use email as primary key (fallback to IP)
- Returns clear error messages when limits exceeded

---

### 3. Insecure Session Cookie Configuration

**Location:** `server/routes.ts` lines 186-189, 224-228

**Problem:** Session cookies lack critical security flags for production:
- Missing `secure: true` flag (allows interception over HTTP)
- Using `sameSite: "lax"` instead of `"strict"`

**Current Code:**
```typescript
res.cookie("sessionId", sessionId, {
  httpOnly: true,
  maxAge: 30 * 24 * 60 * 60 * 1000,
  sameSite: "lax",
});
```

**Fix Required:**
```typescript
res.cookie("sessionId", sessionId, {
  httpOnly: true,
  secure: process.env.NODE_ENV === "production",
  sameSite: "strict",
  maxAge: 30 * 24 * 60 * 60 * 1000,
  path: "/",
});
```

**Apply this fix in three locations:**
1. Line 186-189 (verify-code endpoint)
2. Line 224-228 (signup endpoint)

---

## ðŸŸ  HIGH Issues

### 4. IDOR Vulnerability: Vehicle Operations Missing Account Verification

**Location:** `server/routes.ts` lines 618-634, 636-664

**Problem:** Vehicle update and delete endpoints verify the user is a member of the account, but don't verify that the vehicle ID actually belongs to that account. An attacker could:
1. Be a member of Account A
2. Discover a vehicle ID from Account B
3. Modify or delete that vehicle using their Account A credentials

**Affected Endpoints:**
- `PUT /api/accounts/:accountId/vehicles/:id`
- `DELETE /api/accounts/:accountId/vehicles/:id`

**Fix Required:**
Add vehicle ownership verification before any modification:

```typescript
app.put("/api/accounts/:accountId/vehicles/:id", authMiddleware, accountAccessMiddleware, adminMiddleware, async (req: any, res) => {
  try {
    const id = req.params.id;
    
    // ADD THIS CHECK
    const vehicle = await storage.getVehicleById(id);
    if (!vehicle || vehicle.accountId !== req.accountId) {
      return res.status(404).json({ error: "Vehicle not found" });
    }
    
    const validated = insertVehicleSchema.partial().parse(req.body);
    const updated = await storage.updateVehicle(id, validated);
    // ... rest of handler
  }
});
```

Apply the same check to the DELETE endpoint.

---

### 5. IDOR Vulnerability: Vehicle Member Endpoints

**Location:** `server/routes.ts` lines 667-715

**Problem:** All three vehicle member management endpoints accept a `vehicleId` parameter but don't verify that vehicle belongs to the specified account.

**Affected Endpoints:**
- `GET /api/accounts/:accountId/vehicles/:vehicleId/members`
- `POST /api/accounts/:accountId/vehicles/:vehicleId/members`
- `DELETE /api/accounts/:accountId/vehicles/:vehicleId/members/:userId`

**Fix Required:**
Add verification to all three endpoints:

```typescript
// Add this check at the start of each handler
const vehicle = await storage.getVehicleById(vehicleId);
if (!vehicle || vehicle.accountId !== req.accountId) {
  return res.status(404).json({ error: "Vehicle not found" });
}
```

---

### 6. User Enumeration Vulnerability

**Location:** `server/routes.ts` lines 147-161

**Problem:** The auth request-code endpoint reveals whether an email is registered in the system by returning different messages for existing vs non-existing users.

**Current Response:**
```typescript
res.json({ 
  success: true, 
  userExists: !!existingUser,
  message: existingUser 
    ? "Login code sent to your email" 
    : "This email is not registered. Please sign up first."
});
```

**Attack Vector:** An attacker can enumerate valid email addresses by checking the response.

**Fix Required:**
Return a generic message regardless of user existence:

```typescript
// Always send the email if user exists (but don't tell the client)
if (existingUser) {
  await createAuthCodeForEmail(email);
}

res.json({ 
  success: true, 
  message: "If this email is registered, you will receive a login code."
});
```

**Note:** This changes UX - consider if the trade-off is acceptable for your use case.

---

### 7. In-Memory ACL Storage (Lost on Restart)

**Location:** `server/objectAcl.ts` lines 58-63

**Problem:** Object ACL policies are stored in an in-memory Map and are lost when the server restarts. This means:
- Receipt image access controls disappear on restart
- Users may lose access to their uploaded images
- Or conversely, access controls may be bypassed

**Current Code:**
```typescript
const aclPolicies = new Map<string, ObjectAclPolicy>();
const objectMetadata = new Map<string, ObjectMetadata>();
```

**Fix Required:**
1. Create a new database table for ACL policies:
```sql
CREATE TABLE object_acl_policies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  object_path TEXT NOT NULL UNIQUE,
  owner_id UUID REFERENCES users(id),
  visibility VARCHAR(20) NOT NULL DEFAULT 'private',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

2. Update `objectAcl.ts` to read/write from the database instead of memory
3. Migrate existing in-memory policies on first database write

---

### 8. Missing Security Headers

**Location:** `server/index.ts`

**Problem:** No security headers are configured. Missing:
- Content-Security-Policy
- X-Frame-Options
- X-Content-Type-Options
- X-XSS-Protection
- Referrer-Policy
- Strict-Transport-Security

**Fix Required:**
Install and configure helmet.js:

```bash
npm install helmet
```

```typescript
import helmet from "helmet";

// Add before other middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "https://js.stripe.com"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      frameSrc: ["https://js.stripe.com", "https://hooks.stripe.com"],
      connectSrc: ["'self'", "https://api.stripe.com"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));
```

---

## ðŸŸ¡ MEDIUM Issues

### 9. Race Condition in Auth Code Verification

**Location:** `server/auth.ts` lines 128-138

**Problem:** Auth code verification and deletion are not atomic operations:

```typescript
export async function verifyAuthCode(email: string, code: string): Promise<boolean> {
  const authCode = await storage.getAuthCodeByEmailAndCode(email, code);
  
  if (!authCode) {
    return false;
  }

  await storage.deleteAuthCode(authCode.id);  // Gap between check and delete
  
  return true;
}
```

A race condition could allow the same code to be used multiple times if requests arrive simultaneously.

**Fix Required:**
Use a database transaction with atomic delete:

```typescript
export async function verifyAuthCode(email: string, code: string): Promise<boolean> {
  // Use a single atomic operation that deletes and returns the code
  const deleted = await storage.deleteAuthCodeIfValid(email, code);
  return deleted;
}

// In storage.ts
async deleteAuthCodeIfValid(email: string, code: string): Promise<boolean> {
  const result = await db
    .delete(schema.authCodes)
    .where(and(
      eq(schema.authCodes.email, email),
      eq(schema.authCodes.code, code),
      gte(schema.authCodes.expiresAt, new Date())
    ))
    .returning();
  return result.length > 0;
}
```

---

### 10. Role Escalation Risk

**Location:** `server/routes.ts` lines 511-531

**Problem:** The role update endpoint doesn't validate allowed role values or prevent changing the account owner's role.

**Current Code:**
```typescript
const { role } = req.body;

if (!role) {
  return res.status(400).json({ error: "Role required" });
}

const updated = await storage.updateMemberRole(req.accountId, userId, role);
```

**Attack Vector:** An admin could potentially set someone's role to "owner" or an invalid value.

**Fix Required:**
```typescript
const allowedRoles = ["member", "admin"];
if (!role || !allowedRoles.includes(role)) {
  return res.status(400).json({ error: "Invalid role. Allowed: member, admin" });
}

// Prevent changing the owner's role
const account = await storage.getAccountById(req.accountId);
if (account?.ownerId === userId) {
  return res.status(400).json({ error: "Cannot change account owner's role" });
}

// Prevent demoting yourself if you're the last admin
const requestingUserRole = await storage.getUserRole(req.accountId, req.userId);
if (requestingUserRole === "admin" && userId === req.userId && role === "member") {
  const admins = await storage.getAccountAdmins(req.accountId);
  if (admins.length <= 1) {
    return res.status(400).json({ error: "Cannot demote yourself - you are the only admin" });
  }
}
```

---

### 11. Missing CSRF Protection

**Location:** Throughout `server/routes.ts`

**Problem:** No explicit CSRF tokens are implemented. While `SameSite: lax` cookies provide partial protection, it's not complete.

**Affected Operations:** All POST, PUT, DELETE endpoints

**Fix Required:**
1. Install csurf: `npm install csurf`
2. Add CSRF middleware:
```typescript
import csrf from 'csurf';

const csrfProtection = csrf({ cookie: true });

// Apply to state-changing routes
app.post("/api/auth/logout", authMiddleware, csrfProtection, async (req, res) => { ... });
```

3. Send CSRF token to client and include in requests

**Alternative:** If using a SPA, ensure proper CORS configuration and consider using custom headers for AJAX requests.

---

### 12. âœ… COMPLETED: Rate Limiting on Resource-Intensive Operations

**Status:** Fixed on December 28, 2025

**Implementation:**
- Applied rate limiting to protect against DoS and cost attacks:
  - Receipt upload with AI processing: 10 uploads per minute per account (`receiptUploadLimiter`)
  - VIN lookup (external API): 20 lookups per minute per user (`vinLookupLimiter`)
- Rate limiters use accountId/userId as primary key (fallback to IP)
- Returns clear error messages when limits exceeded
- Prevents abuse of OpenAI API costs and NHTSA VIN lookup service

---

## ðŸ”µ LOW Issues

### 13. Weak Email Validation

**Location:** `server/routes.ts` line 143

**Problem:** Basic regex email validation doesn't catch all invalid formats.

**Current Code:**
```typescript
if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
```

**Fix Required:**
Use a robust email validation library:
```bash
npm install validator
```

```typescript
import { isEmail } from 'validator';

if (!email || !isEmail(email)) {
  return res.status(400).json({ error: "Valid email required" });
}
```

---

### 14. Error Information Disclosure

**Location:** Throughout `server/routes.ts`

**Problem:** Some error handlers may expose internal details in error messages.

**Fix Required:**
Ensure all catch blocks return generic error messages in production:

```typescript
} catch (error) {
  console.error("Error:", error);
  res.status(500).json({ 
    error: process.env.NODE_ENV === "production" 
      ? "An error occurred" 
      : error.message 
  });
}
```

---

### 15. âœ… COMPLETED: VIN Encryption

**Status:** Fixed on December 28, 2025

**Implementation:**
- Integrated `encryptVIN()` and `decryptVIN()` functions into vehicle CRUD operations in `server/storage.ts`
- VINs encrypted with AES-256-GCM plus HMAC-SHA256 search hash stored in `vinHash` column
- Added `vinHash` column to vehicles schema for secure lookups without decryption
- Values automatically decrypted when vehicles are retrieved from database

---

## Implementation Priority

| Priority | Issue | Effort | Impact |
|----------|-------|--------|--------|
| 1 | SSN/FEIN encryption (#1) | Medium | Critical - PII exposure |
| 2 | Auth rate limiting (#2) | Low | Critical - Brute force prevention |
| 3 | Secure cookie flags (#3) | Low | Critical - Session hijacking |
| 4 | Vehicle IDOR fixes (#4, #5) | Low | High - Data breach |
| 5 | Security headers (#8) | Low | High - XSS, clickjacking |
| 6 | User enumeration (#6) | Low | High - Privacy |
| 7 | ACL persistence (#7) | Medium | High - Access control |
| 8 | Role escalation (#10) | Low | Medium - Privilege escalation |
| 9 | Auth race condition (#9) | Medium | Medium - Token reuse |
| 10 | CSRF protection (#11) | Medium | Medium - State modification |
| 11 | Rate limiting general (#12) | Medium | Medium - DoS prevention |
| 12 | Email validation (#13) | Low | Low - Input validation |
| 13 | Error disclosure (#14) | Low | Low - Information leakage |
| 14 | VIN encryption (#15) | Low | Low - Data protection |

---

## Testing Recommendations

After implementing fixes, perform the following security tests:

1. **Authentication Testing:**
   - Verify rate limits block excessive requests
   - Test OTP brute force is prevented
   - Confirm session cookies have correct flags

2. **Authorization Testing:**
   - Attempt IDOR attacks on vehicle endpoints
   - Verify cross-account access is blocked
   - Test role escalation prevention

3. **Input Validation Testing:**
   - Test for SQL injection (should be protected by Drizzle ORM)
   - Test XSS in user input fields
   - Verify email validation

4. **Encryption Verification:**
   - Confirm SSN/FEIN values are encrypted in database
   - Verify decryption works correctly
   - Test that masked values display properly

5. **Security Headers:**
   - Use securityheaders.com to verify headers
   - Test CSP doesn't break application functionality

---

## Notes for Agent

When implementing these fixes:

1. **Test each fix individually** before combining
2. **Create database migrations** for schema changes
3. **Update tests** to cover security scenarios
4. **Document breaking changes** (e.g., user enumeration fix changes UX)
5. **Monitor logs** after deployment for blocked attacks
6. **Consider a security audit** after fixes are implemented
